# プログラム自動実行

本稿では、Raspberry PI（以降、RasPI）の電源投入と同時に、ロボコン競技のプログラムを実行する仕組み・注意点を記載する。

ロボコン当日は、会場でディスプレイやキーボードを接続してRasPIのプログラムを実行するわけにはいかない。

RasPIのシステム管理機能systemdを使用して、これを自動化する。

以下の記事を参考にした。

[systemdを用いたプログラムの自動起動 #組込みLinux - Qiita](https://qiita.com/tkato/items/6a227e7c2c2bde19521c)

# 注意

## とつぜん動く

RasPIの電源投入したときに、ロボットが独りでに動き出す。

このとき、落下・衝突してロボットが破損したり、周囲の人にケガさせてしまうキケンがある。

したがって、systemdを活用するにあたって、開発者は以下の習慣を身に着けるべし。

- ロボットの運転試験を目的としない場合は、電源投入時にRasPIとSPIKEのUSBケーブルを外しておく

- ロボットの運転試験を目的とする場合でも、ターゲットイメージとなっているプログラムが分からないならば、いったんUSBケーブルを外しておく。ディスプレイでターゲットイメージを視認し、ロボットがどのような動きをするかちゃんと把握してから、再度RasPIへ電源投入する。

- 電源投入に先立って、ロボットの周囲は運転に適した環境になっているか、通行人はいないか、よく見渡しておく

> そもそもRasPIを起動する目的が2種類あることを認識すべし。
> 
> #### 1. ロボットの運転試験
> 
> 実施者はロボットが独りでに動くことを想定している。
>
> 運転するときはディスプレイやキーボードを接続しない。
> 
> #### 2. その他（新しいソフトの書き込みやRasPIの学習など）
>
> 実施者はディスプレイやキーボードを通じて、RasPIと対話することを想定している。（いきなり傍らのロボットが動き出したら、ビックリするだろう。）
>
> 電源投入時はロボットとのつながりを断ち、完全起動後に必要に応じて接続すればよい。
> 
> 2.のケースについては、もう一つ注意点がある。["バックグラウンドで動いている"](#バックグラウンドで動いている)にて述べる。

## バックグラウンドで動いている

自動実行を設定すると、開発者がRasPIを起動した目的によらず、RasPIは指定したプログラムを実行する。

特に指示やエラーがなければ、停止することない。

ディスプレイやキーボードを接続してRasPIを操作する場合、バックグラウンドで実行状態が続く。

開発者がこのことに気付かないままバックグラウンド実行が続くのは、以下の理由から不健全である。

- RasPIのリソースを無駄に消費している

- RasPIとSPIKEを接続したときに、急にロボットが動くかも

- 手動でプログラム実行したときに、2つのプログラムが並行して実行されている状態になる。ハードウェア資源や周辺モジュール間通信に競合が発生し、思わぬ不整合が発生するかも。（SPIKEのポート設定がずれて、以降プログラム実行しても、モジュールを認識しなくなるとか・・・！）

そのため、ディスプレイやキーボードを接続してRasPIへ電源投入したときは、<b>真っ先に自動実行サービスを停止させる</b>。

### ⚠️⚠️自動実行サービスを停止させる方法⚠️⚠️

電源投入してデスクトップ画面が表示されたら、ctrl + alt + tを打ち込んでターミナルを開く。

ターミナルで以下を実行する。（本プロジェクトにおいて、サービス名は"RasPIAuto.service"になる。）

```
sudo systemctl status サービス名
```

以下のように表示される（プログラム次第でログ内容はまちまち。）

```
mada
ここにステータス内容を記す
```

＊＊＊の欄に＊＊＊とあることから、＊＊＊の状態にあることが分かる。

この状態を＊＊＊にする。

引き続きターミナルにて、以下を実行する。

```
sudo systemctl stop サービス名
```

これで自動実行サービスを停止させることができた。

もう一度statusコマンドを実行すると、以下のように表示される。

```
mada
ここにステータス内容を記す。
```

＊＊＊の欄に＊＊＊とあることから、＊＊＊の状態にあることが分かる。

ターミナルはもう閉じて大丈夫。

> ソースコードで、周辺モジュールを認識しなかった場合はプログラムクラッシュするように記述できるかもしれない。
>
> しかし、電源投入直後のターゲットイメージがそのような実装になっているとは限らない。
>
> 結果が不明確ならば、それに備えるべし。

# 設定方法

自動実行は一度設定すれば、起動するたびに施行する。

## 0. このディレクトリへ移動

ctrl + alt + tを打ち込んで、ターミナルを開く。

さらに、このディレクトリまで移動する（pwd, ls, cdコマンドを使用せよ）。

以降、カレントディレクトリは以降のようになっていることを想定する。（pwdコマンドで確認）

```
/home/ユーザー名/work/RasPike-ART/sdk/workspace/tenarobo-primarly-mil-2025/boot
```

てなろぼメンバーのRasPIは、ユーザー名: milになっている。

## 1. サービスファイルの配置

引き続きターミナルにて、以下のコマンドを実行する。

```
sudo cp RasPIAuto.service /etc/systemd/system
```

これによって、systemdサービスにサービスファイルRasPIAuto.serviceをコピーした。

さらに、以下のコマンドを実行する。

```
sudo chown root:root /etc/systemd/system/RasPIAuto.service
sudo chmod 644 /etc/systemd/system/RasPIAuto.service
```

これによって、rootユーザーへサービスファイルの実行権限を与えた。

## 2. シェルスクリプトの配置

引き続きターミナルにて、以下のコマンドを実行する。

```
sudo mkdir -p /opt/RasPIAuto/bin
sudo chmod 755 /opt/RasPIAuto/bin
sudo cp autoexec.sh /opt/RasPIAuto/bin
```

これによって、systemdサービスのアクセスする場所にシェルスクリプトautoexec.shをコピーした。

このシェルスクリプトは、(1)プロジェクトのあるディレクトリに移動して、(2)プログラム実行する、という操作を記述する。

引き続きターミナルにて、以下のコマンドを実行する。

```
sudo chown root:root /opt/RasPiSample/bin/autoexec.sh
sudo chmod 755 /opt/RasPiSample/bin/autoexec.sh
```

これによって、rootユーザーへシェルスクリプトの実行権限を与えた。

> ### ヒント
>
> (1)の操作は、RasPIのプロジェクトディレクトリの場所によって失敗する可能性がある。
>
> うまくいかない場合は、autoexec.shを編集して、自身のプロジェクトのディレクトリを指定すべし。

## 3. systemdにサービスファイル更新を通知

引き続きターミナルにて、以下のコマンドを実行する。

```
sudo systemctl daemon-reload
```

## 4. 自動起動の有効化

引き続きターミナルにて、以下のコマンドを実行する。

```
sudo systemctl enable RasPIAuto.service
```

これで有効化された。

以下のコマンドを実行して、

```
sudo systemctl enable RasPIAuto.service
```

Loaded: の行に、

```
/etc/systemd/system/RasPIAuto.service; enabled;vendor preset: disabled
```

と出てくれば完了。

> vendor preset: のところは、ちょっとよく分からない・・・。

## 5. 動作確認

いったん再起動なしで、動作確認する。

> プロジェクトのターゲットイメージを把握しておく。
> 
> ~/work/RasPike-ART/sdk/workspaceにて、最後にmake img=コマンドを実行したときのプログラムで動き出すことになる。

RasPIに、SPIKEなど周辺モジュールを適切に取り付ける。

SPIKEのメインボタンを押して、∞マークになっていることを確認する。

以下のコマンドを実行する。

```
sudo systemctl start RasPIAuto.service
```

ロボットの運転が確認出来る。

以下のコマンドを実行する。

```
sudo systemctl status RasPIAuto.service
```

Active: の行に、「active (running)」と出てきたら完璧。

プログラム上で標準入出力を使用している場合、ここにメッセージが表示される。

以下のコマンドを実行する。

```
sudo systemctl stop RasPiAuto.service
```

これによりRasPI側のプログラムは停止する（SPIKEへの指示は出ているのか、ロボットは動いたままのことがあるので、SPIKEのメインボタンを押して停止する。）

もう一度statusコマンドを実行すると、Active: の行に「active（dead）」と出てくる。

---

ここまで出来たらRasPIを再起動して、起動と同時にロボットが動くことを確認する。

SPIKEのメインボタンを押して、∞マークにしないといけないことに注意。