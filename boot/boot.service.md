# プログラム自動実行

本稿では、Raspberry PI（以降、RasPI）の電源投入と同時に、ロボコン競技のプログラムを実行する仕組み・注意点を記載する。

ロボコン当日は、会場でディスプレイやキーボードを接続してRasPIのプログラムを実行するわけにはいかない。

RasPIのシステム管理機能systemdを使用して、これを自動化する。

以下の記事を参考にした。

[systemdを用いたプログラムの自動起動 #組込みLinux - Qiita](https://qiita.com/tkato/items/6a227e7c2c2bde19521c)

# 注意

## とつぜん動く

RasPIの電源投入したときに、ロボットが独りでに動き出す。

このとき、落下・衝突してロボットが破損したり、周囲の人にケガさせてしまうキケンがある。

したがって、systemdを活用するにあたって、開発者は以下の習慣を身に着けるべし。

- ロボットの運転試験を目的としない場合は、電源投入時にRasPIとSPIKEのUSBケーブルを外しておく

- ロボットの運転試験を目的とする場合でも、ターゲットイメージとなっているプログラムが分からないならば、いったんUSBケーブルを外しておく。ディスプレイでターゲットイメージを視認し、ロボットがどのような動きをするかちゃんと把握してから、再度RasPIへ電源投入する。

- 電源投入に先立って、ロボットの周囲は運転に適した環境になっているか、通行人はいないか、よく見渡しておく

> そもそもRasPIを起動する目的が2種類あることを認識すべし。
> 
> #### 1. ロボットの運転試験
> 
> 実施者はロボットが独りでに動くことを想定している。
>
> 運転するときはディスプレイやキーボードを接続しない。
> 
> #### 2. その他（新しいソフトの書き込みやRasPIの学習など）
>
> 実施者はディスプレイやキーボードを通じて、RasPIと対話することを想定している。（いきなり傍らのロボットが動き出したら、ビックリするだろう。）
>
> 電源投入時はロボットとのつながりを断ち、完全起動後に必要に応じて接続すればよい。
> 
> 2.のケースについては、もう一つ注意点がある。["バックグラウンドで動いている"](#バックグラウンドで動いている)にて述べる。

## バックグラウンドで動いている

自動実行を設定すると、開発者がRasPIを起動した目的によらず、RasPIは指定したプログラムを実行する。

特に指示やエラーがなければ、停止することない。

ディスプレイやキーボードを接続してRasPIを操作する場合、バックグラウンドで実行状態が続く。

開発者がこのことに気付かないままバックグラウンド実行が続くのは、以下の理由から不健全である。

- RasPIのリソースを無駄に消費している

- RasPIとSPIKEを接続したときに、急にロボットが動くかも

- 手動でプログラム実行したときに、2つのプログラムが並行して実行されている状態になる。ハードウェア資源や周辺モジュール間通信に競合が発生し、思わぬ不整合が発生するかも。（SPIKEのポート設定がずれて、以降プログラム実行しても、モジュールを認識しなくなるとか・・・！）

そのため、ディスプレイやキーボードを接続してRasPIへ電源投入したときは、<b>真っ先に自動実行サービスを停止させる</b>。

### ⚠️⚠️習慣づけて！！⚠️⚠️ 自動実行サービスを停止させる方法

電源投入してデスクトップ画面が表示されたら、ctrl + alt + tを打ち込んでターミナルを開く。

ターミナルで以下を実行する。（本プロジェクトにおいて、サービス名は"RasPIAuto.service"になる。）

```
sudo systemctl status サービス名
```

以下のように表示される（プログラム次第でログ内容はまちまち。）

```
mada
ここにステータス内容を記す
```

＊＊＊の欄に＊＊＊とあることから、＊＊＊の状態にあることが分かる。

この状態を＊＊＊にする。

引き続きターミナルにて、以下を実行する。

```
sudo systemctl stop サービス名
```

これで自動実行サービスを停止させることができた。

もう一度statusコマンドを実行すると、以下のように表示される。

```
mada
ここにステータス内容を記す。
```

＊＊＊の欄に＊＊＊とあることから、＊＊＊の状態にあることが分かる。

ターミナルはもう閉じて大丈夫。

> ソースコードで、周辺モジュールを認識しなかった場合はプログラムクラッシュするように記述できるかもしれない。
>
> しかし、電源投入直後のターゲットイメージがそのような実装になっているとは限らない。
>
> 結果が不明確ならば、それに備えるべし。

# 設定方法

